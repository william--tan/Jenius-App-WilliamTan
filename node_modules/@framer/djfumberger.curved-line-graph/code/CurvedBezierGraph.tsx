import * as React from "react"
import { PropertyControls, ControlType, Frame, RenderTarget } from "framer"

// For the best editing experience in VSCode, install Prettier
// https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode

// Everything below is standard React. If you are new, start here:
// https://reactjs.org/docs/getting-started.html#learn-react
// https://reactjs.org/docs/components-and-props.html

// We can tell TypeScript to help us by defining our types
// https://www.typescriptlang.org/docs/handbook/basic-types.html
type Props = {
    text: string
    points: string
    labels: string

    // Graph
    xScale: number
    yMax: number
    xOffset: number
    yOffset: number
    xLabelPosition: string

    // Line
    lineColor: ControlType.Color
    lineWidth: number

    // Labels
    showYLabels: boolean
    labelYOffset: number
    labelColor: ControlType.Color

    // Labels
    showXLabels: boolean
    labelXYOffset: number

    // Show dots
    showDots: boolean
    dotSize: number
    dotColor: ControlType.Color
}

function CurvedLineGraphThumbnail() {
    return (
        <Frame radius={32} background={"rgb(66, 142, 255)"}>
            <Frame width="147" height="113" center={true}>
                <svg width="147" height="113" viewBox="0 0 147 113" fill="none">
                    <path
                        d="M5 108C5 108 9.3617 65 38.8511 65C68.3404 65 71.6596 86 94 86C116.34 86 117 50 142 5"
                        stroke="white"
                        stroke-width="20"
                        stroke-linecap="round"
                    />
                </svg>
            </Frame>
        </Frame>
    )
}

export class CurvedLineGraph extends React.Component<Props> {
    // Return the component contents in JSX
    // https://reactjs.org/docs/introducing-jsx.html

    containerRef = React.createRef()
    canvasRef = React.createRef()

    canvasHeight: number = 0

    render() {
        if (RenderTarget.current() === RenderTarget.thumbnail) {
            return <CurvedLineGraphThumbnail />
        }

        return (
            <div style={style} ref={this.containerRef}>
                <canvas ref={this.canvasRef}></canvas>
            </div>
        )
    }

    componentDidMount() {
        this.update()
    }

    componentDidUpdate() {
        this.update()
    }

    update() {
        this.sizeGraph()
        this.styleGraph()
        this.updateGraph()
    }

    getContext(): CanvasRenderingContext2D {
        return this.canvasRef.current.getContext("2d")
    }

    sizeGraph() {
        var canvas = this.canvasRef.current

        var dpr = 1 //window.devicePixelRatio || 1;
        // Get the size of the canvas in CSS pixels.
        var rect = canvas.getBoundingClientRect()

        canvas.width = this.containerRef.current.offsetWidth * dpr
        canvas.height = this.containerRef.current.offsetHeight * dpr
        this.getContext().scale(dpr, dpr)
        this.canvasHeight = canvas.height
    }

    styleGraph() {}

    updateGraph() {
        let ctx = this.getContext()

        let values = this.props.points.split(",")
        let dataPoints = values.map((yValue, i) => {
            var x = i * this.props.xScale
            var y = (parseFloat(yValue) / this.props.yMax) * this.canvasHeight
            return new Point(
                x + this.props.xOffset,
                this.props.yOffset +
                    (this.canvasHeight -
                        y -
                        Math.max(this.props.lineWidth, this.props.dotSize * 2) /
                            2)
            )
        })
        let curvedLine = new CubicCurvedLine(dataPoints)
        curvedLine.drawPath(
            ctx,
            this.props.xScale,
            this.props.lineColor,
            this.props.lineWidth
        )

        if (this.props.showYLabels) {
            curvedLine.drawYLabels(
                ctx,
                values,
                this.props.labelColor,
                this.props.labelYOffset - this.props.lineWidth
            )
        }

        if (this.props.showXLabels) {
            let labels = this.props.labels.split(",")
            if (this.props.xLabelPosition == "line") {
                curvedLine.drawYLabels(
                    ctx,
                    labels,
                    this.props.labelColor,
                    this.props.lineWidth * 2 + this.props.labelXYOffset
                )
            } else {
                curvedLine.drawXLabels(
                    ctx,
                    labels,
                    this.props.labelColor,
                    this.canvasHeight - 0 + this.props.yOffset
                )
            }
        }

        if (this.props.showDots) {
            curvedLine.drawDots(ctx, this.props.dotColor, this.props.dotSize)
        }
    }

    // Set default values for props if there are none
    // https://reactjs.org/docs/react-component.html#defaultprops
    static defaultProps: Props = {
        width: 375,

        points: "10,20,6,35",
        labels: "a,b,c,d",

        // Graph
        xScale: 100,
        yMax: 75,
        xOffset: 10,
        yOffset: 0,

        // Line
        lineColor: "white",
        lineWidth: 5,

        // Labels
        showXLabels: false,
        labelXColor: "white",
        xLabelPosition: "bottom",
        labelXYOffset: 10,

        // Labels
        showYLabels: false,
        labelYOffset: -10,
        labelColor: "white",

        // Show dots
        showDots: false,
        dotSize: 4,
        dotColor: "white",
    }

    // Add Framer UI for this component (in the properties panel)
    // https://framer.com/learn/docs/components#code
    static propertyControls: PropertyControls<Props> = {
        points: { type: ControlType.String, title: "Points" },
        labels: { type: ControlType.String, title: "Labels" },

        xScale: { type: ControlType.Number, title: "X Scale" },
        yMax: { type: ControlType.Number, title: "Y Max" },
        xOffset: {
            type: ControlType.Number,
            title: "X Offset",
            min: -1000,
            max: 1000,
        },
        yOffset: {
            type: ControlType.Number,
            title: "Y Offset",
            min: -1000,
            max: 1000,
        },

        lineColor: { type: ControlType.Color, title: "Line Color" },
        lineWidth: { type: ControlType.Number, title: "Line Width" },

        showYLabels: { type: ControlType.Boolean, title: "Y Labels" },
        labelYOffset: {
            type: ControlType.Number,
            title: "Y Offset",
            min: -50,
            max: 50,
            hidden(props) {
                return props.showYLabels == false
            },
        },

        showXLabels: { type: ControlType.Boolean, title: "X Labels" },

        xLabelPosition: {
            type: ControlType.Enum,
            title: "X Label Position",
            options: ["bottom", "line"],
            optionTitles: ["Bottom", "Line"],
            hidden(props) {
                return !props.showXLabels
            },
        },
        labelXYOffset: {
            type: ControlType.Number,
            title: "X Y Offset",
            min: -50,
            max: 50,
            hidden(props) {
                return !props.showXLabels
            },
        },

        labelColor: {
            type: ControlType.Color,
            title: "Label Color",
            hidden(props) {
                return !(props.showXLabels == true || props.showYLabels == true)
            },
        },

        showDots: { type: ControlType.Boolean, title: "Show Dots" },
        dotSize: {
            type: ControlType.Number,
            title: "Dot Size",
            hidden(props) {
                return props.showDots == false
            },
        },
        dotColor: {
            type: ControlType.Color,
            title: "Dot Color",
            hidden(props) {
                return props.showDots == false
            },
        },
    }
}

// Define some standard CSS for your component
const style: React.CSSProperties = {
    height: "100%",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    textAlign: "center",
    color: "#8855FF",
    overflow: "visible",
}

class Point {
    x: number = 0
    y: number = 0
    constructor(x: number, y: number) {
        this.x = x
        this.y = y
    }
}

class CubicCurveSegment {
    controlPoint1: Point
    controlPoint2: Point
    constructor(controlPoint1: Point, controlPoint2: Point) {
        this.controlPoint1 = controlPoint1
        this.controlPoint2 = controlPoint2
    }
}

class CubicCurvedLine {
    private firstControlPoints: Point[] = []
    private secondControlPoints: Point[] = []
    dataPoints: Point[] = []

    constructor(dataPoints: Point[]) {
        this.dataPoints = dataPoints
    }

    drawPath(
        ctx: CanvasRenderingContext2D,
        xScale: number,
        lineColor: ControlType.Color,
        lineWidth: number
    ) {
        let controlPoints = this.controlPoints()

        ctx.beginPath()
        ctx.strokeStyle = lineColor
        ctx.lineWidth = lineWidth
        ctx.lineCap = "round"
        this.dataPoints.forEach((point, i) => {
            if (i == 0) {
                ctx.moveTo(point.x, point.y)
            } else {
                let segment = controlPoints[i - 1]

                var cp2 = segment.controlPoint2
                var cp1 = segment.controlPoint1

                ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, point.x, point.y)
            }
        })

        ctx.stroke()
    }

    drawXLabels(
        ctx: CanvasRenderingContext2D,
        labels: string[],
        labelColor: ControlType.Color,
        offset: number
    ) {
        ctx.font = "bold 14px -apple-system, system-ui"
        ctx.textAlign = "center"
        ctx.fillStyle = labelColor
        this.dataPoints.forEach((point, i) => {
            if (labels[i]) {
                ctx.fillText(labels[i], point.x, offset)
            }
        })
    }

    drawYLabels(
        ctx: CanvasRenderingContext2D,
        values: string[],
        labelColor: ControlType.Color,
        offset: number
    ) {
        ctx.font = "bold 14px -apple-system, system-ui"
        ctx.textAlign = "center"
        ctx.fillStyle = labelColor
        this.dataPoints.forEach((point, i) => {
            ctx.fillText(values[i], point.x, point.y + offset)
        })
    }

    drawDots(
        ctx: CanvasRenderingContext2D,
        dotColor: ControlType.Color,
        dotSize: number
    ) {
        ctx.fillStyle = dotColor
        this.dataPoints.forEach((point, i) => {
            ctx.beginPath()
            ctx.arc(point.x, point.y, dotSize, 0, Math.PI * 2, false)
            ctx.fill()
        })
    }

    controlPoints(): CubicCurveSegment[] {
        //Number of Segments
        let count = this.dataPoints.length - 1
        if (count <= 0) {
            return []
        }

        //P0, P1, P2, P3 are the points for each segment, where P0 & P3 are the knots and P1, P2 are the control points.
        if (count == 1) {
            let P0 = this.dataPoints[0]
            let P3 = this.dataPoints[1]

            //Calculate First Control Point
            //3P1 = 2P0 + P3

            let P1x = (2 * P0.x + P3.x) / 3
            let P1y = (2 * P0.y + P3.y) / 3

            this.firstControlPoints.push(new Point(P1x, P1y))

            //Calculate second Control Point
            //P2 = 2P1 - P0
            let P2x = 2 * P1x - P0.x
            let P2y = 2 * P1y - P0.y

            this.secondControlPoints.push(new Point(P2x, P2y))
        } else {
            this.firstControlPoints = []

            var rhsArray: Point[] = []

            //Array of Coefficients
            var a: number[] = []
            var b: number[] = []
            var c: number[] = []

            //for i in 0...count-1 {
            for (var i = 0; i < count; i++) {
                var rhsValueX: number = 0
                var rhsValueY: number = 0

                let P0 = this.dataPoints[i]
                let P3 = this.dataPoints[i + 1]

                if (i == 0) {
                    a.push(0)
                    b.push(2)
                    c.push(1)

                    //rhs for first segment
                    rhsValueX = P0.x + 2 * P3.x
                    rhsValueY = P0.y + 2 * P3.y
                } else if (i == count - 1) {
                    a.push(2)
                    b.push(7)
                    c.push(0)

                    //rhs for last segment
                    rhsValueX = 8 * P0.x + P3.x
                    rhsValueY = 8 * P0.y + P3.y
                } else {
                    a.push(1)
                    b.push(4)
                    c.push(1)

                    rhsValueX = 4 * P0.x + 2 * P3.x
                    rhsValueY = 4 * P0.y + 2 * P3.y
                }

                rhsArray.push(new Point(rhsValueX, rhsValueY))
            }

            //Solve Ax=B. Use Tridiagonal matrix algorithm a.k.a Thomas Algorithm

            //for i in 1...count-1 { //
            for (var i = 1; i < count; i++) {
                let rhsValueX = rhsArray[i].x
                let rhsValueY = rhsArray[i].y

                let prevRhsValueX = rhsArray[i - 1].x
                let prevRhsValueY = rhsArray[i - 1].y

                let m = a[i] / b[i - 1]

                let b1 = b[i] - m * c[i - 1]
                b[i] = b1

                let r2x = rhsValueX - m * prevRhsValueX
                let r2y = rhsValueY - m * prevRhsValueY

                rhsArray[i] = new Point(r2x, r2y)
            }

            // Get First Control Points
            // Last control Point
            let lastControlPointX = rhsArray[count - 1].x / b[count - 1]
            let lastControlPointY = rhsArray[count - 1].y / b[count - 1]

            this.firstControlPoints[count - 1] = new Point(
                lastControlPointX,
                lastControlPointY
            )

            for (var i = count - 2; i >= 0; --i) {
                let nextControlPoint = this.firstControlPoints[i + 1]
                if (nextControlPoint) {
                    let controlPointX =
                        (rhsArray[i].x - c[i] * nextControlPoint.x) / b[i]
                    let controlPointY =
                        (rhsArray[i].y - c[i] * nextControlPoint.y) / b[i]

                    this.firstControlPoints[i] = new Point(
                        controlPointX,
                        controlPointY
                    )
                }
            }

            //Compute second Control Points from first
            for (var i = 0; i < count; i++) {
                if (i == count - 1) {
                    let P3 = this.dataPoints[i + 1]

                    let P1 = this.firstControlPoints[i]
                    if (P1 == null) {
                        continue
                    }
                    let controlPointX = (P3.x + P1.x) / 2
                    let controlPointY = (P3.y + P1.y) / 2

                    this.secondControlPoints.push(
                        new Point(controlPointX, controlPointY)
                    )
                } else {
                    let P3 = this.dataPoints[i + 1]

                    let nextP1 = this.firstControlPoints[i + 1]
                    if (nextP1 == null) {
                        continue
                    }

                    let controlPointX = 2 * P3.x - nextP1.x
                    let controlPointY = 2 * P3.y - nextP1.y

                    this.secondControlPoints.push(
                        new Point(controlPointX, controlPointY)
                    )
                }
            }
        }

        var controlPoints: CubicCurveSegment[] = []

        for (var i = 0; i < count; i++) {
            let firstControlPoint = this.firstControlPoints[i]
            let secondControlPoint = this.secondControlPoints[i]
            let segment = new CubicCurveSegment(
                firstControlPoint,
                secondControlPoint
            )
            controlPoints.push(segment)
        }

        return controlPoints
    }
}
