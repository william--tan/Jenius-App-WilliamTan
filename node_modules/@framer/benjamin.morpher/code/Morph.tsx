import * as React from "react"
import { useState, useMemo, useEffect, useRef } from "react"
import { addPropertyControls, ControlType, RenderTarget, Color } from "framer"
import Morpher from "./Morpher"

const emptyStyle: React.CSSProperties = {
    height: "100%",
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    justifyContent: "center",
    textAlign: "center",
    color: "#8855FF",
    background: "rgba(136, 85, 255, 0.1)",
    overflow: "hidden",
    fontSize: 13,
    fontWeight: 600,
}

export function Morph({
    children,
    width,
    height,
    duration,
    delay,
    loop,
    isSpring,
    stiffness,
    damping,
    mass,
    easeString,
    easePreset,
    easeCustom,
    initialDelay,
}) {
    let svgWidth = 0
    let svgHeight = 0
    let svgFill = ""
    let svgStroke = ""
    let svgStrokeWidth = 0
    let svgLineCap = "butt"
    let svgLineJoin = "inherit"
    let allFills = []

    // Paths of all SVG elements in children.
    let paths = children.map(child => {
        const vectorElement = child.props.children[0]
        if (!vectorElement) {
            return
        }
        const vector = new vectorElement.type(vectorElement.props)

        svgWidth = child.props.width
        svgHeight = child.props.height

        if (svgFill === "") {
            if (vector.props.fill) {
                let color = Color(vector.props.fill)
                allFills.push(Color.toRgbString(color))
            } else {
                svgStroke = vector.props.strokeColor
                svgStrokeWidth = vector.props.strokeWidth
                svgLineCap = vector.props.lineCap
                svgLineJoin = vector.props.lineJoin
            }
        }

        return vector.render().props.children.props.d
    })

    let transforms = children.map(child => {
        const svgElement = child.props.children[0]
        if (!svgElement) {
            return
        }
        const svg = new svgElement.type(svgElement.props)

        return svg.props.frame
    })

    paths = paths.map((newPath, index) => {
        if (!newPath) {
            return
        }
        const path = applyTranslateToPath(newPath, {
            x: transforms[index].x,
            y: transforms[index].y,
        })
        return path
    })

    const hasChildren = children.length > 0
    const hasPath = paths[0] != undefined

    if (!hasChildren) {
        return (
            <div style={emptyStyle}>
                <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="24"
                    height="24"
                    style={{ marginBottom: 10 }}
                >
                    <path
                        d="M 11.136 2.484 C 11.522 1.821 12.478 1.821 12.864 2.484 L 15.334 6.725 C 15.476 6.967 15.712 7.139 15.987 7.199 L 20.784 8.237 C 21.533 8.4 21.828 9.31 21.318 9.881 L 18.048 13.541 C 17.86 13.75 17.77 14.029 17.798 14.308 L 18.293 19.191 C 18.37 19.954 17.596 20.516 16.895 20.207 L 12.403 18.228 C 12.146 18.114 11.854 18.114 11.597 18.228 L 7.105 20.207 C 6.404 20.516 5.63 19.954 5.707 19.191 L 6.202 14.308 C 6.23 14.029 6.14 13.75 5.952 13.541 L 2.682 9.881 C 2.172 9.31 2.467 8.4 3.216 8.237 L 8.013 7.199 C 8.288 7.139 8.524 6.967 8.666 6.725 Z"
                        fill="rgba(136, 85, 255, 1.00)"
                    ></path>
                </svg>
                <p style={{ margin: 0, marginBottom: 5 }}>Connect to Graphic</p>
                <p
                    style={{
                        margin: 0,
                        fontWeight: 500,
                        opacity: 0.5,
                        fontSize: 11,
                    }}
                >
                    With a single shape
                </p>
            </div>
        )
    }

    if (hasPath && hasChildren) {
        return (
            <div
                style={{
                    width: "100%",
                    height: "100%",
                    position: "relative",
                    display: "flex",
                    placeItems: "center",
                    placeContent: "center",
                }}
            >
                <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width={svgWidth}
                    height={svgHeight}
                    style={{
                        position: "relative",
                        overflow: "visible",
                    }}
                >
                    <Morpher
                        paths={paths}
                        duration={duration}
                        maxSegmentLength={1}
                        fill={svgFill}
                        stroke={svgStroke}
                        strokeWidth={svgStrokeWidth}
                        strokeLinecap={svgLineCap}
                        strokeLinejoin={svgLineJoin}
                        delay={delay}
                        loop={loop}
                        isSpring={isSpring}
                        stiffness={stiffness}
                        damping={damping}
                        mass={mass}
                        easeString={easeString}
                        easePreset={easePreset}
                        easeCustom={easeCustom}
                        initialDelay={initialDelay}
                        renderTarget={RenderTarget.current()}
                        allFills={allFills}
                    />
                </svg>
            </div>
        )
    } else {
        return (
            <div style={emptyStyle}>
                <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="24"
                    height="24"
                    style={{ marginBottom: 10 }}
                >
                    <path
                        d="M 10.269 5.99 C 11.039 4.659 12.961 4.659 13.731 5.99 L 21.262 18.998 C 22.034 20.331 21.072 22 19.531 22 L 4.469 22 C 2.928 22 1.966 20.331 2.738 18.998 Z M 11 15 C 11 15.552 11.448 16 12 16 C 12.552 16 13 15.552 13 15 L 13 11 C 13 10.448 12.552 10 12 10 C 11.448 10 11 10.448 11 11 Z M 11 18 C 11 18.552 11.448 19 12 19 C 12.552 19 13 18.552 13 18 C 13 17.448 12.552 17 12 17 C 11.448 17 11 17.448 11 18 Z"
                        fill="#85f"
                    ></path>
                </svg>
                <p style={{ margin: 0, marginBottom: 5 }}>No Path Found</p>
                <p
                    style={{
                        margin: 0,
                        fontWeight: 500,
                        opacity: 0.5,
                        fontSize: 11,
                    }}
                >
                    Please draw a shape
                </p>
            </div>
        )
    }
}

Morph.defaultProps = {
    children: [],
    duration: 1,
    initialDelay: 0,
    delay: 0,
    isSpring: true,
    loop: true,
    stiffness: 300,
    damping: 30,
    mass: 1,
    easeString: true,
    easePreset: "ease",
    easeCustom: "0.645, 0.045, 0.355, 1",
}

addPropertyControls(Morph, {
    children: {
        type: ControlType.Array,
        title: "Children",
        propertyControl: { type: ControlType.ComponentInstance },
    },
    isSpring: {
        type: ControlType.Boolean,
        title: "Type",
        enabledTitle: "Spring",
        disabledTitle: "Ease",
    },
    duration: {
        type: ControlType.Number,
        title: "Duration",
        min: 0,
        max: 10,
        displayStepper: true,
        step: 0.1,
        hidden(props) {
            return props.isSpring === true
        },
    },
    initialDelay: {
        type: ControlType.Number,
        title: "Delay",
        min: 0,
        max: 10,
        displayStepper: true,
        step: 0.1,
    },
    delay: {
        type: ControlType.Number,
        title: "Pause",
        min: 0,
        max: 10,
        displayStepper: true,
        step: 0.1,
    },
    easeString: {
        type: ControlType.Boolean,
        title: "Ease",
        enabledTitle: "Preset",
        disabledTitle: "Custom",
        hidden(props) {
            return props.isSpring === true
        },
    },
    easeCustom: {
        type: ControlType.String,
        title: "Bezier",
        placeholder: "Cubic Bezier Values",
        hidden(props) {
            return props.isSpring === true || props.easeString === true
        },
    },
    easePreset: {
        type: ControlType.Enum,
        title: "Presets",
        defaultValue: "easeInOut",
        options: [
            "linear",
            "easeIn",
            "easeOut",
            "easeInOut",
            "circIn",
            "circOut",
            "circInOut",
            "backIn",
            "backOut",
            "backInOut",
            "anticipate",
        ],
        optionTitles: [
            "Linear",
            "Ease In",
            "Ease Out",
            "Ease In Out",
            "Circ In",
            "Circ Out",
            "Circ In Out",
            "Back In",
            "Back Out",
            "Back In Out",
            "Anticipate",
        ],
        hidden(props) {
            return props.isSpring === true || props.easeString === false
        },
    },
    stiffness: {
        type: ControlType.Number,
        title: "Stiffness",
        min: 0,
        max: 1000,
        hidden(props) {
            return props.isSpring === false
        },
    },
    damping: {
        type: ControlType.Number,
        title: "Damping",
        min: 0,
        max: 100,
        hidden(props) {
            return props.isSpring === false
        },
    },
    mass: {
        type: ControlType.Number,
        title: "Mass",
        min: 0,
        max: 100,
        displayStepper: true,
        step: 0.1,
        hidden(props) {
            return props.isSpring === false
        },
    },
    loop: { type: ControlType.Boolean, title: "Loop" },
})

function applyTranslateToPath(
    path: string,
    translate: { x: number; y: number }
): string {
    const splitPath = path.split(" ")

    let isX = true
    const translatedSplitPath = splitPath.map((v: string) => {
        if (isNaN(v as any)) return v

        const number = parseFloat(v)
        const translation = isX ? translate.x : translate.y
        isX = !isX

        const translatedNumber = number + translation

        return translatedNumber
    })

    return translatedSplitPath.join(" ")
}
