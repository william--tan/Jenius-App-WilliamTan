import * as React from "react"
import { useEffect, useMemo, useRef } from "react"
import { interpolate } from "flubber"
import { motion, useAnimation, useMotionValue, RenderTarget } from "framer"

type Interpolator = (progress: number) => string

const wrap = (min: number, max: number, v: number) => {
    const rangeSize = max - min
    return ((((v - min) % rangeSize) + rangeSize) % rangeSize) + min
}

interface MorpherProps extends React.SVGAttributes<SVGPathElement> {
    paths: string[]
    maxSegmentLength?: number
    fill?: string
    duration?: number
    delay?: number
    loop?: boolean
    isSpring?: boolean
    stiffness?: number
    damping?: number
    mass?: number
    easeString?: string
    easePreset?: string
    easeCustom?: string
    initialDelay?: number
    strokeLinecap?: any
    strokeLinejoin?: any
    renderTarget?: any
    allFills?: any
}

const Path = motion.path as any

export default function Morpher({
    paths,
    fill,
    duration = 1,
    delay = 0,
    maxSegmentLength,
    loop,
    isSpring,
    mass,
    stiffness,
    damping,
    easeString,
    easePreset,
    easeCustom,
    initialDelay,
    renderTarget,
    allFills,
    ...pathProps
}: MorpherProps) {
    const controls = useAnimation()

    const d = useMotionValue("") as any
    const dShadow = useMotionValue(0) as any

    const interpolators = useMemo(
        () =>
            paths.map((a, i) => {
                const b = paths[(i + 1) % paths.length]
                return interpolate(a, b, { maxSegmentLength }) as Interpolator
            }),
        [maxSegmentLength, paths]
    )

    const easeCubicBezier = easeCustom.split(",").map(Number)

    const springTransition = {
        type: "spring",
        isSpring,
        stiffness,
        damping,
        mass,
    }

    const tweenTransition = {
        type: "tween",
        duration: duration,
        ease: easeString ? easePreset : easeCubicBezier,
    }

    async function sequence() {
        let isPlaying = true
        let i = 0
        let colorIndex = 0

        while (isPlaying) {
            controls.set({ ["data-d"]: i } as any)

            const nextIndex = i + 1
            const wrapped = wrap(0, interpolators.length, nextIndex)

            await controls.start({
                ["data-d"]: nextIndex,
                fill: allFills[wrapped],
                transition: isSpring ? springTransition : tweenTransition,
            } as any)

            await controls.start({
                x: 0,
                transition: { duration: delay },
            } as any)

            i++
            colorIndex++

            if (!loop && i >= interpolators.length - 1) {
                isPlaying = false
            }

            if (colorIndex >= interpolators.length - 1) {
                colorIndex = 0
            }
        }
    }

    const pathInterpolator = number => {
        const wrapped = wrap(0, interpolators.length, number)
        const interpolatorIndex = Math.floor(wrapped)
        let interpolator = interpolators[interpolatorIndex]

        if (!interpolator) {
            interpolator = interpolators[0]
        }

        return d.set(interpolator(wrapped - interpolatorIndex))
    }

    useEffect(() => {
        if (initialDelay > 0) {
            d.set(paths[0])
            const timeout = setTimeout(() => {
                sequence()
                dShadow.onChange(number => {
                    pathInterpolator(number)
                })
            }, initialDelay * 1000)

            return () => {
                clearTimeout(timeout)
            }
        } else {
            sequence()
            dShadow.onChange(number => {
                pathInterpolator(number)
            })
        }
    }, [paths.length])

    if (paths.length === 1 || renderTarget === RenderTarget.canvas) {
        return <Path d={paths[0]} fill={allFills[0]} {...pathProps} />
    } else {
        return (
            <Path
                d={d}
                data-d={dShadow}
                fill={allFills[0]}
                animate={controls}
                {...pathProps}
            />
        )
    }
}
