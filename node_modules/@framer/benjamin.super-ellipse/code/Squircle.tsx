import * as React from "react";
import { PropertyControls, ControlType } from "framer";

interface Props {
  text: string;
  width: number;
  height: number;
  radius: number;
  color: string;
  colorTop: string;
  colorBottom: string;
  border: string;
  borderWidth: number;
  angle: number;
  isGradient: boolean;
}

export class Squircle extends React.Component<Props> {
  static defaultProps = {
    radius: 5,
    color: "#0EF",
    colorTop: "#0EF",
    colorBottom: "#40F",
    border: "rgba(0,0,0,0.1)",
    borderWidth: 1,
    angle: 180,
    isGradient: false
  };

  static propertyControls: PropertyControls = {
    isGradient: {
      type: ControlType.Boolean,
      title: "Fill",
      enabledTitle: "Solid",
      disabledTitle: "Linear"
    },
    color: {
      type: ControlType.Color,
      title: "Color",
      hidden(props) {
        return props.isGradient === false;
      }
    },
    colorTop: {
      type: ControlType.Color,
      title: "Top",
      hidden(props) {
        return props.isGradient === true;
      }
    },
    colorBottom: {
      type: ControlType.Color,
      title: "Bottom",
      hidden(props) {
        return props.isGradient === true;
      }
    },
    angle: {
      type: ControlType.Number,
      title: "Angle",
      min: 0,
      max: 360,
      hidden(props) {
        return props.isGradient === true;
      }
    },
    radius: {
      type: ControlType.Number,
      title: "Radius",
      min: 0.2,
      max: 20,
      step: 0.1
    },
    border: { type: ControlType.Color, title: "Stroke" },
    borderWidth: { type: ControlType.Number, title: " ", min: 1 }
  };

  calculatePoints = () => {
    const { radius, width, height } = this.props;
    const xPoints = [];
    const yPoints = [];
    const n = radius;
    const a = width / 2;
    const b = height / 2;

    for (var t = 0; t < 10; t += 0.01) {
      const x =
        Math.pow(Math.abs(Math.cos(t)), 2 / n) * a * Math.sign(Math.cos(t));
      const y =
        Math.pow(Math.abs(Math.sin(t)), 2 / n) * b * Math.sign(Math.sin(t));

      xPoints.push(x + width / 2);
      yPoints.push(y + height / 2);
    }

    const newPoints = xPoints.map((key, index) => {
      return [key, yPoints[index]];
    });

    return newPoints.toString();
  };

  render() {
    const {
      width,
      height,
      isGradient,
      color,
      colorTop,
      colorBottom,
      border,
      borderWidth,
      angle
    } = this.props;

    const gradientID = `gradient${Math.random()}`;

    let anglePI = angle * (Math.PI / 180);
    let currentAngle = {
      x1: Math.round(50 + Math.sin(anglePI) * 50),
      y1: Math.round(50 + Math.cos(anglePI) * 50),
      x2: Math.round(50 + Math.sin(anglePI + Math.PI) * 50),
      y2: Math.round(50 + Math.cos(anglePI + Math.PI) * 50)
    };

    let alphaValueTop = 1;
    let alphaValueBottom = 1;

    if (colorTop.includes("rgba")) {
      let currentAlpha = 100;

      if (colorTop.length > 24) {
        currentAlpha = parseInt(colorTop.substr(colorTop.length - 3, 2));
      } else {
        currentAlpha = parseInt(colorTop.substr(colorTop.length - 2, 2)) * 10;
      }

      alphaValueTop = currentAlpha / 100;
    }

    if (colorBottom.includes("rgba")) {
      let currentAlpha = 100;

      if (colorBottom.length > 24) {
        currentAlpha = parseInt(colorBottom.substr(colorBottom.length - 3, 2));
      } else {
        currentAlpha =
          parseInt(colorBottom.substr(colorBottom.length - 2, 2)) * 10;
      }

      alphaValueBottom = currentAlpha / 100;
    }

    return (
      <svg viewBox={`0 0 ${width} ${height}`} overflow={"visible"}>
        <defs>
          <linearGradient
            id={gradientID}
            x1={`${currentAngle.x1}%`}
            y1={`${currentAngle.y1}%`}
            x2={`${currentAngle.x2}%`}
            y2={`${currentAngle.y2}%`}
          >
            <stop
              offset="0%"
              style={{
                stopColor: colorTop,
                stopOpacity: alphaValueTop
              }}
            />
            <stop
              offset="100%"
              style={{
                stopColor: colorBottom,
                stopOpacity: alphaValueBottom
              }}
            />
          </linearGradient>
        </defs>
        <polyline
          fill={isGradient ? color : `url(#${gradientID})`}
          points={this.calculatePoints()}
          stroke={border}
          strokeWidth={`${borderWidth}`}
        />
      </svg>
    );
  }
}
