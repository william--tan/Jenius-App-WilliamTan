import * as React from "react"
import {
    Frame,
    useCycle,
    PropertyControls,
    ControlType,
    //serverURL,
    RenderTarget,
    Color,
} from "framer"
import * as THREE from "three"
import * as OBJLoader from "three-obj-loader"
import { Vector3, Object3D, Vector2 } from "three"

THREE.Cache.enabled = true
OBJLoader(THREE)

function baseServerURL(url) {
    return "https://mockmatic.netlify.com/" + url
}

function degrees_to_radians(degrees) {
    var pi = Math.PI
    return degrees * (pi / 180)
}

class Model {
    file: string
    scaleX: number = 1.0
    scaleY: number = 1.0
    scaleZ: number = 1.0
    materials: Materials = null
    object: THREE.Object3D
    setupObject(object: THREE.Object3D) {
        this.object = object
        this.materials = new Materials()
    }

    materialMap() {
        return {}
    }

    applyMaterials() {
        let mapping = this.materialMap()
        this.object.children.forEach(element => {
            let found = false
            Object.keys(mapping).forEach(materialName => {
                if (element.name.indexOf(materialName) > -1) {
                    element.material = mapping[materialName]
                    found = true
                }
            })
            if (!found) {
                element.material = this.materials.baseMaterial
            }
        })
    }
}

class ModeliPhoneXSModel extends Model {
    constructor() {
        super()
        this.file = "iphone-xs-lp.mock"
        this.scaleX = this.scaleY = this.scaleZ = 0.9
    }

    materialMap() {
        let m = this.materials
        return {
            Screen: m.screenMaterial,
            Frame: m.frameMaterial,
            MuteSwitch: m.frameMaterial,
            VolumeTop: m.frameMaterial,
            VolumeBottom: m.frameMaterial,
            Sim: m.frameMaterial,
            PowerButton: m.frameMaterial,
            Main: m.frameMaterial,
            Lightning: m.frameMaterial,
            AntennaBands: m.frameBandMaterial,
            Screws: m.frameMaterial,
            Glass: m.glassFrontMaterial,
            Front: m.frontMaterial,
            BackCover: m.baseMaterial,
            GlassBack: m.baseMaterial,
            SpeakerMesh: m.frontMaterial,
        }
    }
}

class Materials {
    // Materials
    baseMaterial: THREE.MeshPhysicalMaterial
    screenMaterial: THREE.MeshBasicMaterial
    glassFrontMaterial: THREE.MeshPhysicalMaterial
    frontMaterial: THREE.MeshPhysicalMaterial
    frameMaterial: THREE.MeshPhysicalMaterial
    frameBandMaterial: THREE.MeshPhysicalMaterial

    // Screen texture
    screenTexture: THREE.Texture

    // Callback when image texture loads
    onload: () => void

    // Offsets for UVs (if needed)
    textureOffset: THREE.Vector2 = new THREE.Vector2(0, 0)
    textureRepeat: THREE.Vector2 = new THREE.Vector2(1, 1)

    updateTexture(screenImage: string) {
        if (screenImage == null) {
            return
        }
        this.screenTexture = new THREE.TextureLoader().load(
            screenImage,
            texture => {
                this.screenMaterial.color = new THREE.Color(
                    "rgba(255,255,255,0.25)"
                )
                this.screenMaterial.needsUpdate = true
                this.onload()
                this.updateTextureOffsets()
            },
            undefined,
            error => { }
        )
        this.screenMaterial.map = this.screenTexture
    }

    updateTextureOffsets() {
        if (this.screenTexture == null) {
            return
        }
        this.screenTexture.wrapS = this.screenTexture.wrapT =
            THREE.ClampToEdgeWrapping
        this.screenTexture.repeat = this.textureRepeat
        this.screenTexture.offset = this.textureOffset
    }

    setup(screenImage: string) {
        
        // Base
        this.baseMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xffffff,
            roughness: 0.0,
            metalness: 0.1,
            reflectivity: 1.0,
        })
        this.baseMaterial.needsUpdate = true
        this.baseMaterial.envMapIntensity = 2.0

        // Screen
        this.screenMaterial = new THREE.MeshBasicMaterial({ color: 0x222222 })
        if (screenImage) {
            this.updateTexture(screenImage)
        }

        // Glass Front
        this.glassFrontMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x000000,
            roughness: 0.0,
            metalness: 0.0,
            reflectivity: 1.0,
        })
        this.glassFrontMaterial.opacity = 0.0
        this.glassFrontMaterial.blending = THREE.AdditiveBlending
        this.glassFrontMaterial.transparent = true
        this.glassFrontMaterial.envMapIntensity = 1.0

        // Front blank
        this.frontMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x000000,
            roughness: 0.0,
            metalness: 0.0,
            reflectivity: 1.0,
        })

        // Side
        this.frameMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xffffff,
            roughness: 0.1,
            metalness: 0.5,
            reflectivity: 1.0,
        })
        this.frameMaterial.envMapIntensity = 2.0

        // Side
        this.frameBandMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xffffff,
            roughness: 0.1,
            metalness: 0.1,
            reflectivity: 1.0,
        })
        this.frameBandMaterial.envMapIntensity = 0.0
    }
    applyEnvironmentMap(environmentMap: THREE.CubeTexture) {
        this.baseMaterial.envMap = environmentMap
        this.baseMaterial.needsUpdate = true
        this.frontMaterial.envMap = environmentMap
        this.frontMaterial.needsUpdate = true
        this.frameBandMaterial.envMap = environmentMap
        this.frameBandMaterial.needsUpdate = true
        this.frameMaterial.envMap = environmentMap
        this.frameMaterial.needsUpdate = true
        this.glassFrontMaterial.envMap = environmentMap
        this.glassFrontMaterial.needsUpdate = true
    }
}

// Define type of property
interface Props {
    image: string
    position: string
    color: string
    lighting: string
    environment: string
    backgroundColor: string
    height: number
    width: number
    deviceRotationX: number
    deviceRotationY: number
    deviceRotationZ: number
    deviceScale: number
    deviceAnimationX: number
    deviceX: number
    deviceY: number
    deviceZ: number
    camera: string
    cameraX: number
    cameraY: number
    cameraZ: number
    cameraFOV: number
    cameraRotationX: number
    cameraRotationY: number
    cameraRotationZ: number
    frameColor: string
    frameReflection: number
    frameMetal: number
    frameRoughness: number
    frontColor: string
    frontReflection: number
    frontMetal: number
    frontRoughness: number
    backColor: string
    backReflection: number
    backMetal: number
    backRoughness: number
    screenReflection: number
    screenReflectionBlur: number
    screenBrightness: number
    ambientLight: string
    ambientLightAmount: number
    spotLight: string
    spotLightAmount: number
    spotLightZ: number
    pointLight: string
    pointLightAmount: number
    pointLightZ: number

    lightingDistance: number

    keyLight: string
    keyLightAmount: number
    fillLight: string
    fillLightAmount: number
    backLight: string
    backLightAmount: number

    shadow: string
    shadowScale: number
    shadowY: number
    shadowX: number
    shadowZ: number

    retina: boolean
}

export class MockmaticTemplates {
    static positions = {
        front: {
            title: "Front",
            props: {
                deviceRotationX: 0,
                deviceRotationY: 0,
                deviceRotationZ: 0,
                deviceX: 0,
                deviceY: 0,
                deviceZ: 0,
                deviceScale: 0.8,
                shadowScale: 1.0,
                shadowX: 0,
                shadowY: -0.15,
                shadowZ: 0,
                cameraFOV: 45,
            },
        },
        angleOne: {
            title: "Angle 1",
            props: {
                deviceRotationX: -35,
                deviceRotationY: -45,
                deviceRotationZ: -35,
                deviceX: 0,
                deviceY: 0.1,
                deviceZ: 0,
                deviceScale: 0.8,
                shadowScale: 1.0,
                shadowX: 0,
                shadowY: -0.05,
                shadowZ: 0,
                cameraFOV: 45,
            },
        },
        angleTwo: {
            title: "Angle 2",
            props: {
                deviceRotationX: -35,
                deviceRotationY: 45,
                deviceRotationZ: 45,
                deviceX: 0,
                deviceY: 0.1,
                deviceZ: 0,
                deviceScale: 0.8,
                shadowScale: 1.0,
                shadowX: 0,
                shadowY: -0.05,
                shadowZ: 0,
                cameraFOV: 45,
            },
        },
        horizontal: {
            title: "Horizontal",
            props: {
                deviceRotationX: -55,
                deviceRotationY: 0,
                deviceRotationZ: -90,
                deviceX: 0,
                deviceY: 0,
                deviceZ: 0,
                deviceScale: 1.0,
                shadowScale: 1.0,
                shadowX: 0,
                shadowY: -0.46,
                shadowZ: 0,
                cameraFOV: 45,
            },
        },
        flat: {
            title: "Flat",
            props: {
                deviceRotationX: -45,
                deviceRotationY: 0,
                deviceRotationZ: -45,
                deviceX: 0,
                deviceY: 0,
                deviceZ: 0,
                deviceScale: 0.8,
                shadowScale: 1.0,
                shadowX: 0,
                shadowY: -0.25,
                shadowZ: 0,
                cameraFOV: 20,
            },
        },
        closeTop: {
            title: "Close Top",
            props: {
                deviceRotationX: 0,
                deviceRotationY: 0,
                deviceRotationZ: 0,
                deviceX: 0,
                deviceY: -2,
                deviceZ: 0,
                deviceScale: 1.5,
                shadowScale: 1.0,
                shadowX: 0,
                shadowY: -0.46,
                shadowZ: 0,
                cameraFOV: 45,
            },
        },
    }

    static colors = {
        black: {
            title: "Black",
            props: {
                frameColor: "#292929",
                frameReflection: 0.75,
                frameMetal: 0.75,
                frameRoughness: 0.1,
                frontColor: "#000000",
                frontReflection: 0.6,
                frontMetal: 0.0,
                frontRoughness: 0.0,
                backColor: "#000000",
                backReflection: 1.0,
                backMetal: 0.1,
                backRoughness: 0.0,
            },
        },
        silver: {
            title: "Silver",
            props: {
                frameColor: "#ffffff",
                frameReflection: 1.0,
                frameMetal: 0.75,
                frameRoughness: 0.1,

                frontColor: "#000000",
                frontReflection: 1.0,
                frontMetal: 0.0,
                //frontRoughness: 0.2,
                frontRoughness: 0.1,
                backColor: "#E6E6E6",
                backReflection: 1.0,
                backMetal: 0.0,
                backRoughness: 0.1,
            },
        },
        gold: {
            title: "Gold",
            props: {
                frameColor: "#D3A57E",
                frameReflection: 1.0,
                frameMetal: 0.85,
                frameRoughness: 0.05,
                frontColor: "#000000",
                frontReflection: 0.75,
                frontMetal: 0.0,
                frontRoughness: 0.0,
                backColor: "#D8B59C",
                backReflection: 1.0,
                backMetal: 0.19,
                backRoughness: 0.0,
            },
        },
        clay: {
            title: "Clay",
            props: {
                frameColor: "#D4D4D4",
                frameReflection: 1,
                frameMetal: 0.0,
                frameRoughness: 1.0,
                frontColor: "#D4D4D4",
                frontReflection: 1,
                frontMetal: 0.0,
                frontRoughness: 1.0,
                backColor: "#D4D4D4",
                backReflection: 0.5,
                backMetal: 0.0,
                backRoughness: 1.0,
            },
        },
        flat: {
            title: "Flat",
            props: {
                frameColor: "#ffffff",
                frameReflection: 0,
                frameMetal: 0.0,
                frameRoughness: 0.0,
                frontColor: "#000000",
                frontReflection: 0,
                frontMetal: 0.0,
                frontRoughness: 0.0,
                backColor: "#D4D4D4",
                backReflection: 0.0,
                backMetal: 0.0,
                backRoughness: 1.0,
            },
        },
    }

    static lighting = {
        standard: {
            title: "Standard",
            props: {
                lightingDistance: 10,
                ambientLight: "#ffffff",
                ambientLightAmount: 0.3,
                keyLight: "#ffffff",
                keyLightAmount: 0.65,
                fillLight: "#ffffff",
                fillLightAmount: 0.65,
                backLight: "#ffffff",
                backLightAmount: 0.62,
            },
        },
        flat: {
            title: "Flat",
            props: {
                lightingDistance: 10,
                ambientLight: "#ffffff",
                ambientLightAmount: 0.88,
                keyLight: "#ffffff",
                keyLightAmount: 0.12,
                fillLight: "#ffffff",
                fillLightAmount: 0.18,
                backLight: "#ffffff",
                backLightAmount: 0.15,
            },
        },
        pink: {
            title: "Pink",
            props: {
                lightingDistance: 10,
                ambientLight: "#FB00FF",
                ambientLightAmount: "0.5",
                keyLight: "#AD00AD",
                keyLightAmount: 0.5,
                fillLight: "#ff00ff",
                fillLightAmount: 0.5,
                backLight: "#ff00ff",
                backLightAmount: 1.0,
            },
        },
        blue: {
            title: "Blue",
            props: {
                lightingDistance: 10,
                ambientLight: "#00206B",
                ambientLightAmount: "0.25",
                keyLight: "#2EB2FF",
                keyLightAmount: 1.0,
                fillLight: "#00206B",
                fillLightAmount: 1.0,
                backLight: "#808080",
                backLightAmount: 1.0,
            },
        },
    }
}

function positionPropNames() {
    let names = Object.keys(MockmaticTemplates.positions).map(key => {
        let obj = MockmaticTemplates.positions[key]
        return obj.title
    })
    names.push("Custom")
    return names
}

function positionKeyNames() {
    let names = Object.keys(MockmaticTemplates.positions)
    names.push("custom")
    return names
}

function positionPropHidden(props) {
    return props.position == "custom" ? false : true
}

function colorPropNames() {
    let names = Object.keys(MockmaticTemplates.colors).map(key => {
        let obj = MockmaticTemplates.colors[key]
        return obj.title
    })
    names.push("Custom")
    return names
}

function colorKeyNames() {
    let names = Object.keys(MockmaticTemplates.colors)
    names.push("custom")
    return names
}

function colorPropHidden(props) {
    return props.color == "custom" ? false : true
}

function lightingPropNames() {
    let names = Object.keys(MockmaticTemplates.lighting).map(key => {
        let obj = MockmaticTemplates.lighting[key]
        return obj.title
    })
    names.push("Custom")
    return names
}

function lightingKeyNames() {
    let names = Object.keys(MockmaticTemplates.lighting)
    names.push("custom")
    return names
}

function lightingPropHidden(props) {
    return props.lighting == "custom" ? false : true
}

export class Mockmatic extends React.Component<Props> {
    container: React.RefObject<HTMLDivElement> = React.createRef()
    mouse = new THREE.Vector2(0, 0)
    scene = new THREE.Scene()
    raycaster = new THREE.Raycaster()
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true , preserveDrawingBuffer: true})
    backgroundColor = new THREE.Color(this.props.backgroundColor)
    threeRootElement = null
    camera = new THREE.PerspectiveCamera(45, 1, 0.01, 100)
    cameraPivot = new THREE.Object3D()

    iphone: THREE.Mesh = null
    shadow: THREE.Mesh = null
    animating: boolean = false
    ambientLight: THREE.AmbientLight = null

    keyLight: THREE.DirectionalLight = null
    backLight: THREE.DirectionalLight = null
    fillLight: THREE.DirectionalLight = null

    spotLight: THREE.SpotLight = null
    pointLight: THREE.PointLight = null

    frameId = null

    shadowBaseScale: number = 3.25
    constantScale: number = 1.0
    cameraBaseZ: number = 5

    model: Model = null

    animationFrameID = null

    state = {
        loading: true,
    }

    domScreenRef : React.RefObject<MockmaticDOMScreen> = React.createRef()

    static defaultProps: Partial<Props> = {
        backgroundColor: "#ff0000",
        position: "front",
        color: "black",
        lighting: "standard",
        environment: "4",
        deviceRotationX: 0,
        deviceRotationY: 0,
        deviceRotationZ: 0,
        deviceScale: 1.0,
        deviceAnimationX: 0,
        deviceX: 0,
        deviceY: 0,
        deviceZ: 0,
        camera: "Pivot",
        cameraX: 0,
        cameraY: 0,
        cameraZ: 1.5,
        cameraFOV: 45,
        cameraRotationX: 0,
        cameraRotationY: 0,
        cameraRotationZ: 0,
        frameColor: "#ffffff",
        frameMetal: 0.5,
        frameReflection: 1.0,
        frameRoughness: 0.0,
        backColor: "#ffffff",
        backMetal: 0.1,
        backReflection: 1.0,
        backRoughness: 1.0,
        frontColor: "#000000",
        frontMetal: 0,
        frontReflection: 1.0,
        frontRoughness: 0.0,
        screenReflection: 0.1,
        screenReflectionBlur: 0.1,
        screenBrightness: 1.0,
        ambientLight: "#ffffff",
        ambientLightAmount: 1.0,
        spotLightAmount: 0.0,
        spotLight: "#ffffff",
        spotLightZ: 2,
        pointLightAmount: 1.0,
        pointLight: "#ffffff",
        pointLightZ: 4,

        lightingDistance: 1,

        keyLight: "#ffffff",
        keyLightAmount: 1.0,
        fillLight: "#ffffff",
        fillLightAmount: 0.75,
        backLight: "#ffffff",
        backLightAmount: 1.0,

        shadow: "rgba(0,0,0,0.6)",
        shadowScale: 1.0,
        shadowY: 0.0,
        shadowX: 0.0,
        shadowZ: 0.0,
        retina: true,
    }

    // Items shown in property panel
    static propertyControls: PropertyControls = {
        image: { type: ControlType.Image, title: "Image" },
        children: { type: ControlType.ComponentInstance, title: "Frame" },

        screenBrightness: {
            type: ControlType.Number,
            title: "· Brightness",
            min: 0,
            max: 1,
            step: 0.01,
        },
        screenReflection: {
            type: ControlType.Number,
            title: "· Reflection",
            min: 0,
            max: 1,
            step: 0.01,
        },
        screenReflectionBlur: {
            type: ControlType.Number,
            title: "· Roughness",
            min: 0,
            max: 0.5,
            step: 0.01,
        },

        position: {
            type: ControlType.Enum,
            title: "Position",
            options: positionKeyNames(),
            optionTitles: positionPropNames,
        },

        deviceScale: {
            type: ControlType.Number,
            title: "· Scale",
            min: 0.1,
            max: 2.0,
            step: 0.01,
            hidden(props) {
                return positionPropHidden(props)
            },
        },
        deviceRotationY: {
            type: ControlType.Number,
            title: "· Rotate",
            min: -180,
            max: 180,
            step: 0.1,
            hidden(props) {
                return positionPropHidden(props)
            },
        },
        deviceRotationX: {
            type: ControlType.Number,
            title: "· Flip",
            min: -180,
            max: 180,
            step: 0.01,
            hidden(props) {
                return positionPropHidden(props)
            },
        },
        deviceRotationZ: {
            type: ControlType.Number,
            title: "· Spin",
            min: -180,
            max: 180,
            step: 0.1,
            hidden(props) {
                return positionPropHidden(props)
            },
        },
        deviceX: {
            type: ControlType.Number,
            title: "· X",
            min: -2,
            max: 2,
            step: 0.01,
            hidden(props) {
                return positionPropHidden(props)
            },
        },
        deviceY: {
            type: ControlType.Number,
            title: "· Y",
            min: -2,
            max: 2,
            step: 0.01,
            hidden(props) {
                return positionPropHidden(props)
            },
        },
        deviceZ: {
            type: ControlType.Number,
            title: "· Z",
            min: -2,
            max: 2,
            step: 0.01,
            hidden(props) {
                return positionPropHidden(props)
            },
        },

        shadow: { type: ControlType.Color, title: "Shadow" },
        //shadowAlpha: { type: ControlType.Number, title: "Shadow", min: 0, max: 1, step: 0.01 },
        shadowScale: {
            type: ControlType.Number,
            title: "· Scale",
            min: 0.5,
            max: 2,
            step: 0.01,
            hidden(props) {
                return positionPropHidden(props)
            },
        },
        shadowX: {
            type: ControlType.Number,
            title: "· X",
            min: -1,
            max: 1,
            step: 0.01,
            hidden(props) {
                return positionPropHidden(props)
            },
        },
        shadowY: {
            type: ControlType.Number,
            title: "· Y",
            min: -1,
            max: 1,
            step: 0.01,
            hidden(props) {
                return positionPropHidden(props)
            },
        },
        shadowZ: {
            type: ControlType.Number,
            title: "· Z",
            min: -1,
            max: 1,
            step: 0.01,
            hidden(props) {
                return positionPropHidden(props)
            },
        },


        // cameraRotationX: { type: ControlType.Number, title: "C Rot X", min: -45, max: 45, step: 0.01 },
        // cameraRotationY: { type: ControlType.Number, title: "C Rot Y", min: -90, max: 45, step: 0.1 },
        // cameraRotationZ: { type: ControlType.Number, title: "CRot Z", min: -180, max: 180, step: 0.1 },

        color: {
            type: ControlType.Enum,
            title: "Color",
            options: colorKeyNames(),
            optionTitles: colorPropNames(),
        },

        frameColor: {
            type: ControlType.Color,
            title: "Frame",
            hidden(props) {
                return colorPropHidden(props)
            },
        },
        frameReflection: {
            type: ControlType.Number,
            title: "· Refl",
            min: 0,
            max: 1,
            step: 0.01,
            hidden(props) {
                return colorPropHidden(props)
            },
        },
        frameMetal: {
            type: ControlType.Number,
            title: "· Metal",
            min: 0,
            max: 1,
            step: 0.01,
            hidden(props) {
                return colorPropHidden(props)
            },
        },
        frameRoughness: {
            type: ControlType.Number,
            title: "· Rough",
            min: 0,
            max: 1,
            step: 0.01,
            hidden(props) {
                return colorPropHidden(props)
            },
        },

        frontColor: {
            type: ControlType.Color,
            title: "Front",
            hidden(props) {
                return colorPropHidden(props)
            },
        },
        frontReflection: {
            type: ControlType.Number,
            title: "· Refl",
            min: 0,
            max: 1,
            step: 0.01,
            hidden(props) {
                return colorPropHidden(props)
            },
        },
        frontMetal: {
            type: ControlType.Number,
            title: "· Metal",
            min: 0,
            max: 1,
            step: 0.01,
            hidden(props) {
                return colorPropHidden(props)
            },
        },
        frontRoughness: {
            type: ControlType.Number,
            title: "· Rough",
            min: 0,
            max: 1,
            step: 0.01,
            hidden(props) {
                return colorPropHidden(props)
            },
        },

        backColor: {
            type: ControlType.Color,
            title: "Back",
            hidden(props) {
                return colorPropHidden(props)
            },
        },
        backReflection: {
            type: ControlType.Number,
            title: "· Refl",
            min: 0,
            max: 1,
            step: 0.01,
            hidden(props) {
                return colorPropHidden(props)
            },
        },
        backMetal: {
            type: ControlType.Number,
            title: "· Metal",
            min: 0,
            max: 1,
            step: 0.01,
            hidden(props) {
                return colorPropHidden(props)
            },
        },
        backRoughness: {
            type: ControlType.Number,
            title: "· Rough",
            min: 0,
            max: 1,
            step: 0.01,
            hidden(props) {
                return colorPropHidden(props)
            },
        },

        lighting: {
            type: ControlType.Enum,
            title: "Lighting",
            options: lightingKeyNames(),
            optionTitles: lightingPropNames(),
        },
        lightingDistance: {
            type: ControlType.Number,
            title: "· Distance",
            min: 0,
            max: 10,
            step: 0.01,
            hidden(props) {
                return lightingPropHidden(props)
            },
        },

        ambientLight: {
            type: ControlType.Color,
            title: "Ambient",
            hidden(props) {
                return lightingPropHidden(props)
            },
        },
        ambientLightAmount: {
            type: ControlType.Number,
            title: "· Amount",
            min: 0,
            max: 1,
            step: 0.01,
            hidden(props) {
                return lightingPropHidden(props)
            },
        },

        keyLight: {
            type: ControlType.Color,
            title: "Key Light",
            hidden(props) {
                return lightingPropHidden(props)
            },
        },
        keyLightAmount: {
            type: ControlType.Number,
            title: "· Amount",
            min: 0,
            max: 2,
            step: 0.01,
            hidden(props) {
                return lightingPropHidden(props)
            },
        },

        fillLight: {
            type: ControlType.Color,
            title: "Fill Light",
            hidden(props) {
                return lightingPropHidden(props)
            },
        },
        fillLightAmount: {
            type: ControlType.Number,
            title: "· Amount",
            min: 0,
            max: 2,
            step: 0.01,
            hidden(props) {
                return lightingPropHidden(props)
            },
        },

        backLight: {
            type: ControlType.Color,
            title: "Back Light",
            hidden(props) {
                return lightingPropHidden(props)
            },
        },
        backLightAmount: {
            type: ControlType.Number,
            title: "· Amount",
            min: 0,
            max: 2,
            step: 0.01,
            hidden(props) {
                return lightingPropHidden(props)
            },
        },

        environment: {
            type: ControlType.Enum,
            title: "Environment",
            options: ["1", "2", "3", "4", "5", "6"],
            optionTitles: [
                "Outside 1",
                "Outside 2",
                "Office",
                "Studio",
                "Neon",
                "Light Box",
            ],
        },

        cameraZ: {
            type: ControlType.Number,
            title: "Camera",
            min: -4,
            max: 4,
            step: 0.01,
        },
        cameraX: {
            type: ControlType.Number,
            title: "· X",
            min: -6,
            max: 6,
            step: 0.01,
        },
        cameraY: {
            type: ControlType.Number,
            title: "· Y",
            min: -6,
            max: 6,
            step: 0.01,
        },

        cameraFOV: {
            type: ControlType.Number,
            title: "Cam FOV",
            min: 0,
            max: 90,
            step: 0.01,
            hidden(props) {
                return positionPropHidden(props)
            },
        },
        cameraRotationX: {
            type: ControlType.Number,
            title: "· Rotate",
            min: -180,
            max: 180,
            step: 0.01,
        },
        cameraRotationY: {
            type: ControlType.Number,
            title: "· Flip",
            min: -90,
            max: 90,
            step: 0.01,
        },
    }


    onKeyDown(e) {
        if (e.keyCode == 17) {
            this.isPressingCtrl = true
        }
        if (this.isPressingCtrl && e.keyCode == 83) {
            this.screenshot()
        }
    }

    onKeyUp(e) {
        if (e.keyCode == 17) {
            this.isPressingCtrl = false
        }
    }

    isPressingCtrl = false
    handlePress = this.onKeyDown.bind(this)
    handlePressUp = this.onKeyUp.bind(this)

    setupKeyEvents() {
        if (RenderTarget.current() !== RenderTarget.canvas) {
            window.addEventListener("keydown", this.handlePress)
            window.addEventListener("keyup", this.handlePressUp)
        }
    }

    removeKeyEvents() {
        if (RenderTarget.current() !== RenderTarget.canvas) {
            window.removeEventListener("keydown", this.handlePress)        
            window.removeEventListener("keyup", this.handlePressUp)        
        }
    }
        
    componentDidMount() {
        // Load the model
        this.model = new ModeliPhoneXSModel()

        // Setup
        const container = this.container.current
        this.renderer.domElement.style.pointerEvents = 'none'
        container.appendChild(this.renderer.domElement)

        this.handleResize(this.props)

        this.setupScene()
        this.setupLights()
        this.setupThreePointLighting()
        this.setupPhoneShadow()
        this.setupKeyEvents()
        console.log("load phone")
        this.loadPhone(obj => {
            console.log("loaded phone")
            console.log(obj)
            this.updateEnvironment()
            this.setState({ loading: false })
        })
    }

    componentWillUnmount() {
        cancelAnimationFrame(this.animationFrameID)
        const container = this.container.current
        if (this.renderer.domElement) {
            container.removeChild(this.renderer.domElement)
        }
        this.removeKeyEvents()
    }

    componentDidUpdate(oldProps) {
        if (this.state.loading == true) {
            return
        }
        if (oldProps.image != this.props.image) {
            setTimeout(() => {
                if (this.model.materials) {
                    this.model.materials.updateTexture(this.props.image)
                }
            }, 10)
        }
        if (oldProps.environment != this.props.environment) {
            this.updateEnvironment()
        }
        console.log("did update")
        this.updatePhone()
        this.updateCamera()
        this.updateMaterials()
        this.updateLights()
        this.updateShadow()
        this.update()
    }

    componentWillReceiveProps(props) {
        if (props !== this.props) {
            this.handleResize(props)
        }       
    }

    screenshot() {
        // For screenshots to work with WebGL renderer, preserveDrawingBuffer should be set to true.
        // open in new window like this
        var w = window.open('', '');
        w.document.title = "Screenshot";
        //w.document.body.style.backgroundColor = "red";
        var img = new Image();
        img.src = this.renderer.domElement.toDataURL();
        w.document.body.appendChild(img);

    // download file like this.
    //var a = document.createElement('a');
    //a.href = renderer.domElement.toDataURL().replace("image/png", "image/octet-stream");
    //a.download = 'canvas.png'
    //a.click();        
    }

    currentProps() {
        var positionProps = MockmaticTemplates.positions[this.props.position]
        var colorProps = MockmaticTemplates.colors[this.props.color]
        var lightingProps = MockmaticTemplates.lighting[this.props.lighting]

        if (positionProps == null) {
            positionProps = {}
        }
        if (colorProps == null) {
            colorProps = {}
        }
        if (lightingProps == null) {
            lightingProps = {}
        }

        return {
            ...Mockmatic.defaultProps,
            ...this.props,
            ...positionProps.props,
            ...colorProps.props,
            ...lightingProps.props,
        }
    }

    handleResize = (props: Props) => {
        const { distance, height, width } = props
        const aspect = width / height
        this.camera.aspect = aspect
        this.camera.updateProjectionMatrix()
        this.renderer.setSize(width, height)
    }

    updateCamera() {
        let p = this.currentProps()
        if (this.camera == null) {
            return
        }

        let angleX = degrees_to_radians(p.cameraRotationX)
        let angleY = degrees_to_radians(p.cameraRotationY)

        this.camera.position.x = p.cameraX * -1
        this.camera.position.y = p.cameraY
        this.cameraPivot.rotation.set(angleY, angleX, 0)

        var fov = (this.isFrameBasedImage()) ? 45 : p.cameraFOV 
        let lastFOV = this.camera.fov
        let zAdjust = ((fov - 45) / 45) * -10
        this.camera.position.z = p.cameraZ + zAdjust + this.cameraBaseZ //p.cameraZ + zAdjust + this.cameraBaseZ// + (5 * Math.sin(p.cameraX))

        this.camera.fov = fov

        if (lastFOV != fov) {
            this.camera.updateProjectionMatrix()
        }
    }

    updatePhone() {
        //if (this.iphone == null) { return }
        if (this.model == null) {
            return
        }
        if (this.model.object == null) {
            return
        }
        let p = this.currentProps()
        let iphone = this.model.object
        iphone.scale.set(
            p.deviceScale * this.model.scaleX,
            p.deviceScale * this.model.scaleY,
            p.deviceScale * this.model.scaleZ
        )
        iphone.rotation.x = degrees_to_radians(p.deviceRotationX)
        iphone.rotation.y = degrees_to_radians(p.deviceRotationY)
        iphone.rotation.z = degrees_to_radians(p.deviceRotationZ)
        iphone.position.x = p.deviceX + p.deviceAnimationX // + 0.05
        iphone.position.y = p.deviceY// - 0.001
        iphone.position.z = p.deviceZ
    }

    updateLightsOld() {
        this.ambientLight.intensity = this.props.ambientLightAmount
        this.ambientLight.color = new THREE.Color(this.props.ambientLight)
        this.spotLight.intensity = this.props.spotLightAmount
        this.spotLight.color = new THREE.Color(this.props.spotLight)
        this.spotLight.position.z = this.props.spotLightZ
        this.pointLight.intensity = this.props.pointLightAmount
        this.pointLight.color = new THREE.Color(this.props.pointLight)
        this.pointLight.position.z = this.props.pointLightZ
    }

    updateLights() {
        let p = this.currentProps()

        let distance = p.lightingDistance

        this.keyLight.position.set(-distance, 0, distance)
        this.fillLight.position.set(distance, 0, distance)
        this.backLight.position.set(distance, 0, -distance).normalize()

        this.ambientLight.intensity = p.ambientLightAmount
        this.ambientLight.color = new THREE.Color(p.ambientLight)

        this.keyLight.intensity = p.keyLightAmount
        this.keyLight.color = new THREE.Color(p.keyLight)

        this.fillLight.intensity = p.fillLightAmount
        this.fillLight.color = new THREE.Color(p.fillLight)

        this.backLight.intensity = p.backLightAmount
        this.backLight.color = new THREE.Color(p.backLight)
    }

    updateShadow() {
        if (this.shadow == null) {
            return
        }
        let p = this.currentProps()
        this.shadow.rotation.z = degrees_to_radians(p.deviceRotationZ)
        this.shadow.rotation.x = degrees_to_radians(p.deviceRotationX)
        this.shadow.rotation.y = degrees_to_radians(p.deviceRotationY)
        this.shadow.position.set(
            p.deviceX + p.shadowX,
            p.shadowY * p.deviceScale + p.deviceY,
            (p.shadowZ - 0.15) * p.deviceScale + p.deviceZ
        )
        this.shadow.material.opacity = Color(this.props.shadow).a
        this.shadow.material.color = new THREE.Color(this.props.shadow)
        this.shadow.scale.set(
            p.shadowScale *
                p.deviceScale *
                this.shadowBaseScale *
                this.model.scaleX,
            p.shadowScale *
                p.deviceScale *
                this.shadowBaseScale *
                this.model.scaleY,
            p.shadowScale *
                p.deviceScale *
                this.shadowBaseScale *
                this.model.scaleZ
        )
    }

    isFrameBasedImage() {
        return (this.props.children && this.props.children.length > 0)
    }

    updateMaterials() {
        let p = this.currentProps()
        let materials = this.model.materials
        if (this.model.materials == null) {
            console.log("no materials")
            return
        }
        materials.glassFrontMaterial.opacity = p.screenReflection
        materials.glassFrontMaterial.roughness = p.screenReflectionBlur

        let c = p.screenBrightness
        if (materials.screenTexture) {
            materials.screenMaterial.color = new THREE.Color(c, c, c)
        }


        // Connected to child
        if (this.isFrameBasedImage()) {                          
            materials.glassFrontMaterial.opacity = Math.min(p.screenReflection, 0.2)                                    
            materials.screenMaterial.color.set('black')
            materials.screenMaterial.opacity   = 0;
            materials.screenMaterial.blending  = THREE.NoBlending;
        }

        materials.frameMaterial.metalness = p.frameMetal
        materials.frameMaterial.reflectivity = p.frameReflection
        materials.frameMaterial.roughness = p.frameRoughness
        materials.frameMaterial.color = new THREE.Color(p.frameColor)
        materials.frameMaterial.envMapIntensity =
            p.frameMetal > 0 || p.frameReflection > 0 ? 2.0 : 0.0

        materials.frameBandMaterial.metalness = p.frameMetal
        materials.frameBandMaterial.reflectivity = p.frameReflection
        materials.frameBandMaterial.roughness = 0.3
        materials.frameBandMaterial.color = new THREE.Color(p.frameColor)
        materials.frameBandMaterial.envMapIntensity =
            p.frameMetal > 0 || p.frameReflection > 0 ? 2.0 : 0.0

        materials.baseMaterial.metalness = p.backMetal
        materials.baseMaterial.reflectivity = p.backReflection
        materials.baseMaterial.roughness = p.backRoughness
        materials.baseMaterial.color = new THREE.Color(p.backColor)

        materials.frontMaterial.metalness = p.frontMetal
        materials.frontMaterial.reflectivity = p.frontReflection
        materials.frontMaterial.roughness = p.frontRoughness
        materials.frontMaterial.color = new THREE.Color(p.frontColor)
        materials.frontMaterial.envMapIntensity =
            p.frontMetal > 0 || p.frontReflection > 0 ? 1.0 : 0.0
    }

    update() {
        this.renderer.render(this.scene, this.camera)     
        if (this.domScreenRef.current) {
            this.domScreenRef.current.update()
        }   
    }

    updateLoop() {
        this.update()
        if (this.animating) {
            requestAnimationFrame(this.updateLoop)
        }
    }

    render() {
        let style : React.CSSProperties = {
            backgroundColor: "clear",
            width: "100%",
            height: "100%",
            position: "relative",
        }

        let contentStyle : React.CSSProperties = {
            ...style,
            pointerEvents: "none"
        }
        let content = this.state.loading ? <MockmaticLoading /> : <span />
        let props = this.currentProps()
        return (
            <div style={style}>
                {content}
                <MockmaticDOMScreen 
                    deviceRotationX={props.deviceRotationX} 
                    deviceRotationY={props.deviceRotationY}
                    deviceRotationZ={props.deviceRotationZ}
                    deviceX={props.deviceX}
                    deviceY={props.deviceY}
                    deviceZ={props.deviceZ}
                    deviceScale={props.deviceScale}
                    camera={this.camera} 
                    ref={this.domScreenRef} 
                    width={this.props.width} 
                    height={this.props.height}
                    hidden={this.state.loading}>
                {this.props.children}
                </MockmaticDOMScreen>                
                <div ref={this.container} style={contentStyle} />
            </div>
        )
    }

    setupAnimation() {
        if (RenderTarget.current() == RenderTarget.canvas) {
            this.update()
            return
        }
        cancelAnimationFrame(this.animationFrameID)
        this.animating = true
        this.animationFrameID = requestAnimationFrame(this.updateLoop)
    }

    setupScene() {
        if (this.props.retina) {
            this.renderer.setPixelRatio(
                window.devicePixelRatio ? window.devicePixelRatio : 1
            )
        }
        this.cameraPivot.add(this.camera)
        this.scene.add(this.cameraPivot)
        this.camera.lookAt(this.scene.position)
        this.renderer.setClearColor(this.props.backgroundColor, 0)
    }

    // setupControls() {
    //     if (RenderTarget.current() == RenderTarget.canvas) {
    //         return
    //     }
    //     var controls = new OrbitControls(this.camera)
    //     controls.enableZoom = true
    //     this.orbitControls = controls
    //     this.orbitControls.target = new Vector3(
    //         degrees_to_radians(this.props.cameraRotationX),
    //         degrees_to_radians(this.props.cameraRotationY),
    //         0
    //     )
    // }

    setupThreePointLighting() {
        let distance = this.props.lightingDistance

        this.keyLight = new THREE.PointLight(
            new THREE.Color("hsl(30, 100%, 75%)"),
            1.0
        )
        this.keyLight.position.set(-distance, 0, distance)

        this.fillLight = new THREE.PointLight(
            new THREE.Color("hsl(240, 100%, 75%)"),
            0.75
        )
        this.fillLight.position.set(distance, 0, distance)

        this.backLight = new THREE.PointLight(
            new THREE.Color("hsl(240, 100%, 75%)"),
            0.75
        )
        this.backLight.position.set(distance, 0, -distance).normalize()

        this.scene.add(this.keyLight)
        this.scene.add(this.fillLight)
        this.scene.add(this.backLight)
    }

    setupLights() {
        this.ambientLight = new THREE.AmbientLight(
            0xffffff,
            this.props.ambientLightAmount
        )
        this.scene.add(this.ambientLight)
    }

    loadPhone(didLoadCallback) {
        var scope = this
        let url = baseServerURL(this.model.file)
        var objLoader = new THREE.OBJLoader()
        var fileLoader = new THREE.FileLoader()
        //fileLoader.crossOrigin = ""

        //loader.setPath( this.path );
        //alert(url)
        fileLoader.load(
            url,
            text => {
                let t = text.replace(/a!/gi, "0")
                let obj = objLoader.parse(t)
                this.phoneDidLoad(obj)
                didLoadCallback(obj)
                //
            },
            progress => {
                console.log(progress)
            },
            error => {
                alert(error)
                console.log(error)
            }
        )
    }

    phoneDidLoad(object) {
        this.scene.add(object)
        this.model.setupObject(object)
        let map = this.setupEnvironmentMap(() => {})
        this.setupPhoneMaterials(map)
        this.model.applyMaterials()
        this.updatePhone()
        this.updateShadow()
        this.shadow.visible = true
    }

    setupPhoneMaterials(environmentMap: THREE.CubeTexture) {
        let materials = this.model.materials
        if (materials == null) {
            return
        }
        materials.onload = () => {
            this.updateMaterials()
            this.update()
        }
        materials.setup(this.props.image)
        materials.applyEnvironmentMap(environmentMap)
    }

    updateEnvironment() {
        let map = this.setupEnvironmentMap(texture => {
            this.model.materials.applyEnvironmentMap(texture)
            this.updateLights()
            this.update()
        })
    }

    setupEnvironmentMap(onload): THREE.CubeTexture {
        // Environment Map
        var r = "environment" + this.props.environment + "/"
        let extension = ".png"
        if (this.props.environment == "1") {
            extension = ".jpg"
        }

        var urls = [
            r + "px" + extension,
            r + "nx" + extension,
            r + "py" + extension,
            r + "ny" + extension,
            r + "pz" + extension,
            r + "nz" + extension,
        ]

        let serverURLS = urls.map(obj => {
            return baseServerURL(obj)
        })
        var textureCube = new THREE.CubeTextureLoader().load(
            serverURLS,
            texture => {
                if (onload) {
                    onload(texture)
                }
            }
        )
        textureCube.format = THREE.RGBFormat
        textureCube.mapping = THREE.CubeReflectionMapping
        textureCube.encoding = THREE.sRGBEncoding
        return textureCube
    }

    setupPhoneShadow() {
        var texture = new THREE.TextureLoader().load(
            baseServerURL("shadow-white.png")
        )
        let bgMaterial = new THREE.MeshBasicMaterial({
            map: texture,
            side: THREE.DoubleSide,
        })
        bgMaterial.transparent = true
        bgMaterial.color = new THREE.Color(this.props.shadow)
        var backgroundMesh = new THREE.Mesh(
            new THREE.PlaneGeometry(1.5, 1.85, 0),
            bgMaterial
        )
        backgroundMesh.position.set(0, 0.0, 0.0)

        this.scene.add(backgroundMesh)
        this.shadow = backgroundMesh
        this.shadow.visible = false
    }
}

function MockmaticLoading() {
    let style: React.CSSProperties = {
        width: "100%",
        height: "100%",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        backgroundColor: "rgb(97, 176, 255,0.62)",
        border: "2px solid rgb(97, 176, 255,1.0)",
        color: "black",
        padding: "30px",
        textAlign: "center",
        fontSize: "18pt",
    }
    return (
        <div style={style}>
            <span>Loading assets</span>
        </div>
    )
}


interface DOMScreenProps {
    width: number
    height: number
    camera: THREE.PerspectiveCamera
    frame: number
    deviceRotationX: number
    deviceRotationY: number
    deviceRotationZ: number
    deviceScale: number
    deviceX: number
    deviceY: number
    deviceZ: number
    hidden: boolean
}

class MockmaticDOMScreen extends React.Component<DOMScreenProps> {
    renderer : THREE.CSS3DRenderer = new THREE.CSS3DRenderer()
    container: React.RefObject<HTMLDivElement> = React.createRef()
    scene: THREE.Scene = new THREE.Scene()
    object: THREE.CSS3DObject = null
    objectPivot: THREE.CSS3DObject = null
    childRef: React.RefObject<HTMLDivElement> = React.createRef()

    screenSize = new Vector2(375, 812)

    // Magic numbers
    sceneScale = 0.005
    offset = new Vector3(-13,0,25)

    componentDidMount() {
        // Setup
        const container = this.container.current
        container.appendChild(this.renderer.domElement)
        
        this.handleResize(this.props)
        this.createElement()

        this.scene.scale.set(this.sceneScale, this.sceneScale, this.sceneScale);      
    }

    componentDidUpdate(oldProps) {
        this.updateScreen()
    }

    componentWillReceiveProps(props) {
        if (props !== this.props) {
            this.handleResize(props)
        }       
    }

    createElement() {
        var element = document.createElement( 'div' );
        element.id = 'screen'
        element.style.width = this.screenSize.width + 'px';
        element.style.height = this.screenSize.height + 'px';

        this.object = new THREE.CSS3DObject( this.childRef.current );        

        this.objectPivot = new THREE.Object3D()        
        this.objectPivot.add(this.object)
        this.scene.add( this.objectPivot );          
    }

    handleResize = (props: DOMScreenProps) => {
        const { height, width } = props
        const aspect = width / height
        this.renderer.setSize(width, height)
    }    

    update() {
        this.renderer.render( this.scene, this.props.camera );
    }

    updateScreen() {
        if (this.object == null) { return }
        this.object.position.set(this.offset.x , this.offset.y, this.offset.z)
        this.objectPivot.position.set( (this.props.deviceX * 1.0/this.sceneScale), (this.props.deviceY  * 1.0/this.sceneScale), (this.props.deviceZ * 1.0/this.sceneScale))
        this.objectPivot.rotation.set(degrees_to_radians(this.props.deviceRotationX), degrees_to_radians(this.props.deviceRotationY), degrees_to_radians(this.props.deviceRotationZ))
        this.objectPivot.scale.set(this.props.deviceScale, this.props.deviceScale, this.props.deviceScale)
    }

    render() {
        let childContainerStyle: React.CSSProperties = {
            overflow: 'hidden',
            borderRadius: '30px',
            width: '375px',
            height: '812px',
        }

        let style: React.CSSProperties = {
            width: "100%",
            height: "100%",
            position: "absolute",
            display: this.props.hidden ? 'none' : 'block'
        }

        let children = React.Children.map(this.props.children, (c) => React.cloneElement(c, {width: this.screenSize.width, height: this.screenSize.height}))

        return <div style={style} ref={this.container}><div ref={this.childRef} style={childContainerStyle}>{children}</div></div>
    }
}


/**
 * Based on http://www.emagix.net/academic/mscs-project/item/camera-sync-with-css3-and-webgl-threejs
 * @author mrdoob / http://mrdoob.com/
 * @author yomotsu / https://yomotsu.net/
 */
THREE.CSS3DObject = function ( element ) {

	THREE.Object3D.call( this );

	this.element = element;
	this.element.style.position = 'absolute';

	this.addEventListener( 'removed', function () {

		if ( this.element.parentNode !== null ) {

			this.element.parentNode.removeChild( this.element );

		}

	} );

};

THREE.CSS3DObject.prototype = Object.create( THREE.Object3D.prototype );
THREE.CSS3DObject.prototype.constructor = THREE.CSS3DObject;

THREE.CSS3DSprite = function ( element ) {

	THREE.CSS3DObject.call( this, element );

};

THREE.CSS3DSprite.prototype = Object.create( THREE.CSS3DObject.prototype );
THREE.CSS3DSprite.prototype.constructor = THREE.CSS3DSprite;

//

THREE.CSS3DRenderer = function () {

	console.log( 'THREE.CSS3DRenderer', THREE.REVISION );

	var _width, _height;
	var _widthHalf, _heightHalf;

	var matrix = new THREE.Matrix4();

	var cache = {
		camera: { fov: 0, style: '' },
		objects: new WeakMap()
	};

	var domElement = document.createElement( 'div' );
	domElement.style.overflow = 'hidden';

	this.domElement = domElement;

	var cameraElement = document.createElement( 'div' );

	cameraElement.style.WebkitTransformStyle = 'preserve-3d';
	cameraElement.style.transformStyle = 'preserve-3d';

	domElement.appendChild( cameraElement );

	var isIE = /Trident/i.test( navigator.userAgent );

	this.getSize = function () {

		return {
			width: _width,
			height: _height
		};

	};

	this.setSize = function ( width, height ) {

		_width = width;
		_height = height;
		_widthHalf = _width / 2;
		_heightHalf = _height / 2;

		domElement.style.width = width + 'px';
		domElement.style.height = height + 'px';

		cameraElement.style.width = width + 'px';
		cameraElement.style.height = height + 'px';

	};

	function epsilon( value ) {

		return Math.abs( value ) < 1e-10 ? 0 : value;

	}

	function getCameraCSSMatrix( matrix ) {

		var elements = matrix.elements;

		return 'matrix3d(' +
			epsilon( elements[ 0 ] ) + ',' +
			epsilon( - elements[ 1 ] ) + ',' +
			epsilon( elements[ 2 ] ) + ',' +
			epsilon( elements[ 3 ] ) + ',' +
			epsilon( elements[ 4 ] ) + ',' +
			epsilon( - elements[ 5 ] ) + ',' +
			epsilon( elements[ 6 ] ) + ',' +
			epsilon( elements[ 7 ] ) + ',' +
			epsilon( elements[ 8 ] ) + ',' +
			epsilon( - elements[ 9 ] ) + ',' +
			epsilon( elements[ 10 ] ) + ',' +
			epsilon( elements[ 11 ] ) + ',' +
			epsilon( elements[ 12 ] ) + ',' +
			epsilon( - elements[ 13 ] ) + ',' +
			epsilon( elements[ 14 ] ) + ',' +
			epsilon( elements[ 15 ] ) +
		')';

	}

	function getObjectCSSMatrix( matrix, cameraCSSMatrix ) {

		var elements = matrix.elements;
		var matrix3d = 'matrix3d(' +
			epsilon( elements[ 0 ] ) + ',' +
			epsilon( elements[ 1 ] ) + ',' +
			epsilon( elements[ 2 ] ) + ',' +
			epsilon( elements[ 3 ] ) + ',' +
			epsilon( - elements[ 4 ] ) + ',' +
			epsilon( - elements[ 5 ] ) + ',' +
			epsilon( - elements[ 6 ] ) + ',' +
			epsilon( - elements[ 7 ] ) + ',' +
			epsilon( elements[ 8 ] ) + ',' +
			epsilon( elements[ 9 ] ) + ',' +
			epsilon( elements[ 10 ] ) + ',' +
			epsilon( elements[ 11 ] ) + ',' +
			epsilon( elements[ 12 ] ) + ',' +
			epsilon( elements[ 13 ] ) + ',' +
			epsilon( elements[ 14 ] ) + ',' +
			epsilon( elements[ 15 ] ) +
		')';

		if ( isIE ) {

			return 'translate(-50%,-50%)' +
				'translate(' + _widthHalf + 'px,' + _heightHalf + 'px)' +
				cameraCSSMatrix +
				matrix3d;

		}

		return 'translate(-50%,-50%)' + matrix3d;

	}

	function renderObject( object, camera, cameraCSSMatrix ) {

		if ( object instanceof THREE.CSS3DObject ) {

			var style;

			if ( object instanceof THREE.CSS3DSprite ) {

				// http://swiftcoder.wordpress.com/2008/11/25/constructing-a-billboard-matrix/

				matrix.copy( camera.matrixWorldInverse );
				matrix.transpose();
				matrix.copyPosition( object.matrixWorld );
				matrix.scale( object.scale );

				matrix.elements[ 3 ] = 0;
				matrix.elements[ 7 ] = 0;
				matrix.elements[ 11 ] = 0;
				matrix.elements[ 15 ] = 1;

				style = getObjectCSSMatrix( matrix, cameraCSSMatrix );

			} else {

				style = getObjectCSSMatrix( object.matrixWorld, cameraCSSMatrix );

			}

			var element = object.element;
			var cachedObject = cache.objects.get( object );

			if ( cachedObject === undefined || cachedObject.style !== style ) {

				element.style.WebkitTransform = style;
				element.style.transform = style;

				var objectData = { style: style };

				if ( isIE ) {

					objectData.distanceToCameraSquared = getDistanceToSquared( camera, object );

				}

				cache.objects.set( object, objectData );

			}

			if ( element.parentNode !== cameraElement ) {

				cameraElement.appendChild( element );

			}

		}

		for ( var i = 0, l = object.children.length; i < l; i ++ ) {

			renderObject( object.children[ i ], camera, cameraCSSMatrix );

		}

	}

	var getDistanceToSquared = function () {

		var a = new THREE.Vector3();
		var b = new THREE.Vector3();

		return function ( object1, object2 ) {

			a.setFromMatrixPosition( object1.matrixWorld );
			b.setFromMatrixPosition( object2.matrixWorld );

			return a.distanceToSquared( b );

		};

	}();

	function filterAndFlatten( scene ) {

		var result = [];

		scene.traverse( function ( object ) {

			if ( object instanceof THREE.CSS3DObject ) result.push( object );

		} );

		return result;

	}

	function zOrder( scene ) {

		var sorted = filterAndFlatten( scene ).sort( function ( a, b ) {

			var distanceA = cache.objects.get( a ).distanceToCameraSquared;
			var distanceB = cache.objects.get( b ).distanceToCameraSquared;

			return distanceA - distanceB;

		} );

		var zMax = sorted.length;

		for ( var i = 0, l = sorted.length; i < l; i ++ ) {

			sorted[ i ].element.style.zIndex = zMax - i;

		}

	}

	this.render = function ( scene, camera ) {

		var fov = camera.projectionMatrix.elements[ 5 ] * _heightHalf;

		if ( cache.camera.fov !== fov ) {

			if ( camera.isPerspectiveCamera ) {

				domElement.style.WebkitPerspective = fov + 'px';
				domElement.style.perspective = fov + 'px';

			}

			cache.camera.fov = fov;

		}

		scene.updateMatrixWorld();

		if ( camera.parent === null ) camera.updateMatrixWorld();

		if ( camera.isOrthographicCamera ) {

			var tx = - ( camera.right + camera.left ) / 2;
			var ty = ( camera.top + camera.bottom ) / 2;

		}

		var cameraCSSMatrix = camera.isOrthographicCamera ?
			'scale(' + fov + ')' + 'translate(' + epsilon( tx ) + 'px,' + epsilon( ty ) + 'px)' + getCameraCSSMatrix( camera.matrixWorldInverse ) :
			'translateZ(' + fov + 'px)' + getCameraCSSMatrix( camera.matrixWorldInverse );

		var style = cameraCSSMatrix +
			'translate(' + _widthHalf + 'px,' + _heightHalf + 'px)';

		if ( cache.camera.style !== style && ! isIE ) {

			cameraElement.style.WebkitTransform = style;
			cameraElement.style.transform = style;

			cache.camera.style = style;

		}

		renderObject( scene, camera, cameraCSSMatrix );

		if ( isIE ) {

			// IE10 and 11 does not support 'preserve-3d'.
			// Thus, z-order in 3D will not work.
			// We have to calc z-order manually and set CSS z-index for IE.
			// FYI: z-index can't handle object intersection
			zOrder( scene );

		}

	};

};